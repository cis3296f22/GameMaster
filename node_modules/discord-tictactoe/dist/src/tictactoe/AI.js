"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const localize = __importDefault(require("../i18n/localize"));
const Player = require("./Player");
/**
 * @class AI is the default second player for if the user does not invite anyone else to play.
 */
class AI {
    constructor() {
        this.id = 'AI';
        this.displayName = localize.default.__('game.ai');
    }
    /**
     * @method Used to determine the next step of the game for the AI during it's turn.
     * @param {any} game The current state of the game.
     * @returns object stating the cell of interest and the score calculation.
     */
    operate(game) {
        //within-operate functions
        //NOTE: This is a major change from the original version, which uses a rewards-based algorithm to find the best series of moves per turn. While effective in a 3x3 board
        //it takes a while to run on any board larger than that, and as a result this new version, which mimics generic human players, to take it's place as it is notably quicker.
        /**
         * @method main logic behind determining where to place the next item on the board. While it is not as sound logic as the recursive minimax() method, it better mirrors the way
         * a human would play the game, and provides a system where it is possible to win rather than just tie.
         * @param {any} game The current state of the game.
         * @param {any} player The player value currently being searched for. This allows for reusability between offensive and defensive.
         */
        function checkBoard(game, player) {
            var cell = -1;
            var currentSpot = -1;
            //check rows for potential win
            for (var i = 0; i < game.boardSize; i++) {
                for (var j = 0; j < game.boardSize; j++) {
                    //if we have 2 in a row from expected player
                    if (j > 0) {
                        currentSpot = game.toIndex(i, j);
                        if (game.board[currentSpot - 1] == player && game.board[currentSpot - 1] == game.board[currentSpot]) {
                            //check if left is in bounds and unoccupied
                            if (game.board[currentSpot - 2] > (i * game.boardSize) && game.board[currentSpot - 2] == 0) {
                                cell = currentSpot - 2;
                            }
                            //check if right is in bounds and unoccupied
                            if (game.board[currentSpot + 1] < ((i + 1) * game.boardSize) && game.board[currentSpot + 1] == 0) {
                                cell = currentSpot + 1;
                            }
                        }
                    }

                    //if we have 2 in a column from expected player
                    if (i > 0) {
                        currentSpot = game.toIndex(j, i);
                        if (game.board[currentSpot - (1 * game.boardSize)] == player && game.board[currentSpot - (1 * game.boardSize)] == game.board[currentSpot]) {
                            //check if above is in bounds and unoccupied
                            if (game.board[currentSpot - (2 * game.boardSize)] > (i * game.boardSize) && game.board[currentSpot - (2 * game.boardSize)] == 0) {
                                cell = currentSpot - (2 * game.boardSize);
                            }
                            //check if below is in bounds and unoccupied
                            if (game.board[currentSpot + (1 * game.boardSize)] < ((i + (1 * game.boardSize)) * game.boardSize) && game.board[currentSpot + (1 * game.boardSize)] == 0) {
                                cell = currentSpot + (1 * game.boardSize);
                            }
                        }
                    }
                }
            }

            //Check diagonals
            for (int i = 1; i < game.boardSize; i++) {
                currentSpot = game.toIndex(i, i);
                if (game.toIndex(i - 1, i - 1) == player && game.toIndex(i - 1, i - 1) == game.board[currentSpot]) {
                    //check if top left is in bounds
                    if ((i - 2) >= 0 && game.board[game.toIndex(i - 2, i - 2)] == 0) {
                        cell = (i - 2) * (i - 2);
                    }
                    //check if bottom right is in bounds]
                    if ((i + 1) < game.boardSize && game.board[game.toIndex(i + 1, i + 1)] == 0) {
                        cell = (i + 1) * (i + 1);
                    }
                }
                
            }

            return cell;
        }
        /**
         * @method Checks for any defensive moves that can be made.
         * @param {any} game The current state of the game.
         * @returns The cell that prevents a win, if any.
         */
        function defensive(game) {
            var player = game.currentPlayer;
            if (player == 1) {
                player = 2;
            }
            else {
                player = 1;
            }
            return checkBoard(game, player);
        }
        /**
         * @method Checks for any offensive moves that can be made
         * @param {any} game The current state of the game.
         * @returns The cell that progresses towards a win, if any.
         */
        function offensive(game) {
            return checkBoard(game, game.currentPlayer);
        }

        /*RECURSIVE VERSION - while this works for a 3x3 board, gets exceptionally large. Instead, a more simplified version will be used.
         * if (!game.boardEmpty && game.emptyCellAmount <= 9) {
            return AI.minimax(game.clone(), game.emptyCellAmount, game.currentPlayer);
        }
        else {*/

        //cell set to -1 as default
        var cell = -1;
        //play defensively first
        if ((cell = defensive(game)) == -1) {
            if ((cell = offensive(game)) == -1) {
                //randomly guess if no offensive or defensive options are available
                do {
                    cell = Math.floor(Math.random() * (game.boardSize ** 2));
                } while (game.board[cell] != 0);
            }
        }
        return { move: cell, score: 0 };
        //}
    }
    /**
     * @method Standard toString method
     * @returns displayName of the AI
     */
    toString() {
        return this.displayName;
    }
    /**
     * @method Recursive method to determine the best possible outcome given the current state of the game and possible outcomes going forward.
     * @param {any} game The current state of the game.
     * @param {any} depth Recursive level
     * @param {any} player which player this iteration is looking at.
     * @returns An object showing the cell and score of the best possible move.
     */
    static minimax(game, depth, player) {
        const winner = game.winner;
        const type = AI.getComputeType(player);
        let best;
        if (type === 1) {
            best = { score: -1000 };
        }
        else {
            best = { score: +1000 };
        }
        if (depth === 0 || winner) {
            return { score: AI.getComputeType(winner) };
        }
        game.board.forEach((cell, index) => {
            if (cell === 0) {
                game.updateBoard(player, index);
                const deep = this.minimax(game, depth - 1, (0, Player.getOpponent)(player));
                game.updateBoard(0, index);
                deep.move = index;
                if (type === 1) {
                    if (deep.score > best.score) {
                        best = deep;
                    }
                }
                else {
                    if (deep.score < best.score) {
                        best = deep;
                    }
                }
            }
        });
        return best;
    }
    /**
     * @method Used to determine the best option going forward.
     * @param {any} player The current player
     * @returns the player value
     */
    static getComputeType(player) {
        if (player === 1) {
            return -1;
        }
        else if (player === 2) {
            return 1;
        }
        else {
            return 0;
        }
    }
}
exports.default = AI;
